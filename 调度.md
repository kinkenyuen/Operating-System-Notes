# 简介

调度，简单来说，就是在多个就绪的进程中，选择一个来使用CPU

调度的时机有：

* 在创建一个新进程之后，需要决定是运行父进程还是运行子进程
* 在一个进程退出时必须做出调度决策，一个进程不再运行，所以必须从就绪进程集中选择另外某个进程
* 当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另一个进程运行
* 在一个I/O中断发生时，必须做出调度决策

根据如何处理时钟中断，可以把调度算法分类两类：

* **非抢占式调度算法**：选一个进程，让它一直运行直至被阻塞(阻塞在I/O上或等待另一个进程)，或者进程自动释放CPU
* **抢占式调度算法：**选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行(如果存在一个就绪进程)。进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把CPU控制返回给调度程序

根据系统环境不同，可以把调度算法的环境分为三类：

* 批处理
* 交互式
* 实时

# 批处理系统中的调度

## 先来先服务(first-come first-served)

这是最简单的非抢占式调度算法，使用该算法，进程按照它们请求CPU的顺序使用CPU。基本上，有一个就绪进程的单一队列。上午，当第一个作业从外部进人系统后，就立即开始并允许运行它所期望的时间长度，该作业不会因为运行太长时间而被中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程被阻塞时，就绪队列中的第一个进程接着运行。当在被阻塞的进程变为就绪时，就像一个新来到的作业一样，排到就绪队列的末尾，即排在所有进程最后

不过，先来先服务也有明显的缺点。假设有一个一次运行1秒钟的计算密集型进程和很少使用CPU但是每个都要进行1000次磁盘读操作才能完成的大量I/O密集型进程存在。计算密集进程运行1秒钟，接着读一个磁盘块。所有的I/O进程开始运行并读磁盘。当该计算密集进程获得其磁盘块时，它运行下一个1秒钟，紧跟随着的是所有I/O进程

这样做的结果是，每个I/O进程在每秒钟内读到一个磁盘块，要花费1000秒钟才能完成操作。如果有一个调度算法每10ms抢占计算密集型进程，那么I/O进程将在10秒钟内完成而不是1000秒钟，而且还不会对计算密集型进程产生多少延迟

## 最短作业优先

这是一种适用于运行时间可以预知的另一个非抢占式的批处理调度算法，从等待运行的进程中选择执行时间最短的那个来运行

最短任务优先有一些优点，比如简单，并且这种策略减小了所有进程的平均运行时间 (Average Turnaround TIme)。 然而，它的缺点是，如果不断地有新的短期进程不断加入时，他会需要花更长的时间来完成那些长期进程

## 最短剩余时间优先

最短作业优先的抢占式版本是最短剩余时间优先（shortest remaining time next）算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。再次提醒，有关的运行时间必须提前掌握。当一个新的作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式可以使新的短作业获得良好的服务

# 交互式系统中的调度

## 轮转调度

## 优先级调度

## 多级队列

## 最短进程优先

## 保证调度

## 彩票调度

## 公平分享调度

# 实时系统中的调度

